/*
 * generated by Xtext 2.26.0
 */
package dk.sdu.mmmi.mdsd.serializer;

import com.google.inject.Inject;
import dk.sdu.mmmi.mdsd.services.X21GrammarAccess;
import dk.sdu.mmmi.mdsd.x21.AnonymousLambda;
import dk.sdu.mmmi.mdsd.x21.CustomType;
import dk.sdu.mmmi.mdsd.x21.DataAccess;
import dk.sdu.mmmi.mdsd.x21.DataDecl;
import dk.sdu.mmmi.mdsd.x21.DataVariable;
import dk.sdu.mmmi.mdsd.x21.Div;
import dk.sdu.mmmi.mdsd.x21.ElementList;
import dk.sdu.mmmi.mdsd.x21.Equals;
import dk.sdu.mmmi.mdsd.x21.Function;
import dk.sdu.mmmi.mdsd.x21.FunctionReference;
import dk.sdu.mmmi.mdsd.x21.GreaterThan;
import dk.sdu.mmmi.mdsd.x21.GreaterThanOrEquals;
import dk.sdu.mmmi.mdsd.x21.IfStatement;
import dk.sdu.mmmi.mdsd.x21.Input;
import dk.sdu.mmmi.mdsd.x21.Int;
import dk.sdu.mmmi.mdsd.x21.IntType;
import dk.sdu.mmmi.mdsd.x21.Lambda;
import dk.sdu.mmmi.mdsd.x21.LessThan;
import dk.sdu.mmmi.mdsd.x21.LessThanOrEquals;
import dk.sdu.mmmi.mdsd.x21.LetStatement;
import dk.sdu.mmmi.mdsd.x21.Minus;
import dk.sdu.mmmi.mdsd.x21.Mul;
import dk.sdu.mmmi.mdsd.x21.NewStatement;
import dk.sdu.mmmi.mdsd.x21.Node;
import dk.sdu.mmmi.mdsd.x21.NodeRef;
import dk.sdu.mmmi.mdsd.x21.None;
import dk.sdu.mmmi.mdsd.x21.Output;
import dk.sdu.mmmi.mdsd.x21.Parenthesis;
import dk.sdu.mmmi.mdsd.x21.Plus;
import dk.sdu.mmmi.mdsd.x21.Stream;
import dk.sdu.mmmi.mdsd.x21.StringType;
import dk.sdu.mmmi.mdsd.x21.VarAssignment;
import dk.sdu.mmmi.mdsd.x21.X21;
import dk.sdu.mmmi.mdsd.x21.X21Package;
import java.util.Set;
import org.eclipse.emf.ecore.EObject;
import org.eclipse.emf.ecore.EPackage;
import org.eclipse.xtext.Action;
import org.eclipse.xtext.Parameter;
import org.eclipse.xtext.ParserRule;
import org.eclipse.xtext.serializer.ISerializationContext;
import org.eclipse.xtext.serializer.acceptor.SequenceFeeder;
import org.eclipse.xtext.serializer.sequencer.AbstractDelegatingSemanticSequencer;
import org.eclipse.xtext.serializer.sequencer.ITransientValueService.ValueTransient;

@SuppressWarnings("all")
public class X21SemanticSequencer extends AbstractDelegatingSemanticSequencer {

	@Inject
	private X21GrammarAccess grammarAccess;
	
	@Override
	public void sequence(ISerializationContext context, EObject semanticObject) {
		EPackage epackage = semanticObject.eClass().getEPackage();
		ParserRule rule = context.getParserRule();
		Action action = context.getAssignedAction();
		Set<Parameter> parameters = context.getEnabledBooleanParameters();
		if (epackage == X21Package.eINSTANCE)
			switch (semanticObject.eClass().getClassifierID()) {
			case X21Package.ANONYMOUS_LAMBDA:
				sequence_Element(context, (AnonymousLambda) semanticObject); 
				return; 
			case X21Package.CUSTOM_TYPE:
				sequence_Type(context, (CustomType) semanticObject); 
				return; 
			case X21Package.DATA_ACCESS:
				sequence_DataAccess(context, (DataAccess) semanticObject); 
				return; 
			case X21Package.DATA_DECL:
				sequence_DataDecl(context, (DataDecl) semanticObject); 
				return; 
			case X21Package.DATA_VARIABLE:
				sequence_DataVariable(context, (DataVariable) semanticObject); 
				return; 
			case X21Package.DIV:
				sequence_MulDiv(context, (Div) semanticObject); 
				return; 
			case X21Package.ELEMENT_LIST:
				sequence_ElementList(context, (ElementList) semanticObject); 
				return; 
			case X21Package.EQUALS:
				sequence_LogicExp(context, (Equals) semanticObject); 
				return; 
			case X21Package.FUNCTION:
				sequence_Function(context, (Function) semanticObject); 
				return; 
			case X21Package.FUNCTION_REFERENCE:
				sequence_FunctionOrLambda(context, (FunctionReference) semanticObject); 
				return; 
			case X21Package.GREATER_THAN:
				sequence_LogicExp(context, (GreaterThan) semanticObject); 
				return; 
			case X21Package.GREATER_THAN_OR_EQUALS:
				sequence_LogicExp(context, (GreaterThanOrEquals) semanticObject); 
				return; 
			case X21Package.IF_STATEMENT:
				sequence_IfStatement(context, (IfStatement) semanticObject); 
				return; 
			case X21Package.INPUT:
				sequence_NameAndType(context, (Input) semanticObject); 
				return; 
			case X21Package.INT:
				sequence_Primary(context, (Int) semanticObject); 
				return; 
			case X21Package.INT_TYPE:
				sequence_Type(context, (IntType) semanticObject); 
				return; 
			case X21Package.LAMBDA:
				sequence_Lambda_NameAndType(context, (Lambda) semanticObject); 
				return; 
			case X21Package.LESS_THAN:
				sequence_LogicExp(context, (LessThan) semanticObject); 
				return; 
			case X21Package.LESS_THAN_OR_EQUALS:
				sequence_LogicExp(context, (LessThanOrEquals) semanticObject); 
				return; 
			case X21Package.LET_STATEMENT:
				sequence_LetStatement(context, (LetStatement) semanticObject); 
				return; 
			case X21Package.MINUS:
				sequence_Exp(context, (Minus) semanticObject); 
				return; 
			case X21Package.MUL:
				sequence_MulDiv(context, (Mul) semanticObject); 
				return; 
			case X21Package.NEW_STATEMENT:
				sequence_NewStatement(context, (NewStatement) semanticObject); 
				return; 
			case X21Package.NODE:
				sequence_Node(context, (Node) semanticObject); 
				return; 
			case X21Package.NODE_REF:
				sequence_Element(context, (NodeRef) semanticObject); 
				return; 
			case X21Package.NONE:
				sequence_None(context, (None) semanticObject); 
				return; 
			case X21Package.OUTPUT:
				sequence_Element(context, (Output) semanticObject); 
				return; 
			case X21Package.PARAMETER:
				sequence_NameAndType(context, (dk.sdu.mmmi.mdsd.x21.Parameter) semanticObject); 
				return; 
			case X21Package.PARENTHESIS:
				sequence_Primary(context, (Parenthesis) semanticObject); 
				return; 
			case X21Package.PLUS:
				sequence_Exp(context, (Plus) semanticObject); 
				return; 
			case X21Package.STREAM:
				sequence_Stream(context, (Stream) semanticObject); 
				return; 
			case X21Package.STRING_TYPE:
				sequence_Type(context, (StringType) semanticObject); 
				return; 
			case X21Package.VAR_ASSIGNMENT:
				sequence_VarAssignment(context, (VarAssignment) semanticObject); 
				return; 
			case X21Package.X21:
				sequence_X21(context, (X21) semanticObject); 
				return; 
			}
		if (errorAcceptor != null)
			errorAcceptor.accept(diagnosticProvider.createInvalidContextOrTypeDiagnostic(semanticObject, context));
	}
	
	/**
	 * <pre>
	 * Contexts:
	 *     LogicExp.Equals_1_0_0 returns DataAccess
	 *     LogicExp.LessThan_1_1_0 returns DataAccess
	 *     LogicExp.GreaterThan_1_2_0 returns DataAccess
	 *     LogicExp.LessThanOrEquals_1_3_0 returns DataAccess
	 *     LogicExp.GreaterThanOrEquals_1_4_0 returns DataAccess
	 *     Exp returns DataAccess
	 *     Exp.Plus_1_0_0_0 returns DataAccess
	 *     Exp.Minus_1_0_1 returns DataAccess
	 *     MulDiv returns DataAccess
	 *     MulDiv.Mul_1_0_0_0 returns DataAccess
	 *     MulDiv.Div_1_0_1_0 returns DataAccess
	 *     Primary returns DataAccess
	 *     DataAccess returns DataAccess
	 *
	 * Constraint:
	 *     (ref=[DataRef|ID] varRefs+=[DataVariable|ID]*)
	 * </pre>
	 */
	protected void sequence_DataAccess(ISerializationContext context, DataAccess semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Declaration returns DataDecl
	 *     DataDecl returns DataDecl
	 *
	 * Constraint:
	 *     (name=ID variables+=DataVariable variables+=DataVariable*)
	 * </pre>
	 */
	protected void sequence_DataDecl(ISerializationContext context, DataDecl semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     DataVariable returns DataVariable
	 *
	 * Constraint:
	 *     (name=ID type=Type)
	 * </pre>
	 */
	protected void sequence_DataVariable(ISerializationContext context, DataVariable semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, X21Package.Literals.DATA_VARIABLE__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, X21Package.Literals.DATA_VARIABLE__NAME));
			if (transientValues.isValueTransient(semanticObject, X21Package.Literals.DATA_VARIABLE__TYPE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, X21Package.Literals.DATA_VARIABLE__TYPE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getDataVariableAccess().getNameIDTerminalRuleCall_0_0(), semanticObject.getName());
		feeder.accept(grammarAccess.getDataVariableAccess().getTypeTypeParserRuleCall_2_0(), semanticObject.getType());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     ElementList returns ElementList
	 *
	 * Constraint:
	 *     (elements+=Element elements+=Element*)
	 * </pre>
	 */
	protected void sequence_ElementList(ISerializationContext context, ElementList semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Element returns AnonymousLambda
	 *
	 * Constraint:
	 *     body=Lambda
	 * </pre>
	 */
	protected void sequence_Element(ISerializationContext context, AnonymousLambda semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, X21Package.Literals.ANONYMOUS_LAMBDA__BODY) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, X21Package.Literals.ANONYMOUS_LAMBDA__BODY));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getElementAccess().getBodyLambdaParserRuleCall_1_1_0(), semanticObject.getBody());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Element returns NodeRef
	 *
	 * Constraint:
	 *     ref=Node
	 * </pre>
	 */
	protected void sequence_Element(ISerializationContext context, NodeRef semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, X21Package.Literals.NODE_REF__REF) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, X21Package.Literals.NODE_REF__REF));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getElementAccess().getRefNodeParserRuleCall_0_1_0(), semanticObject.getRef());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Element returns Output
	 *
	 * Constraint:
	 *     name=ID
	 * </pre>
	 */
	protected void sequence_Element(ISerializationContext context, Output semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, X21Package.Literals.OUTPUT__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, X21Package.Literals.OUTPUT__NAME));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getElementAccess().getNameIDTerminalRuleCall_2_2_0(), semanticObject.getName());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     LogicExp.Equals_1_0_0 returns Minus
	 *     LogicExp.LessThan_1_1_0 returns Minus
	 *     LogicExp.GreaterThan_1_2_0 returns Minus
	 *     LogicExp.LessThanOrEquals_1_3_0 returns Minus
	 *     LogicExp.GreaterThanOrEquals_1_4_0 returns Minus
	 *     Exp returns Minus
	 *     Exp.Plus_1_0_0_0 returns Minus
	 *     Exp.Minus_1_0_1 returns Minus
	 *
	 * Constraint:
	 *     (left=Exp_Minus_1_0_1 right=MulDiv)
	 * </pre>
	 */
	protected void sequence_Exp(ISerializationContext context, Minus semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, X21Package.Literals.MINUS__LEFT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, X21Package.Literals.MINUS__LEFT));
			if (transientValues.isValueTransient(semanticObject, X21Package.Literals.MINUS__RIGHT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, X21Package.Literals.MINUS__RIGHT));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getExpAccess().getMinusLeftAction_1_0_1(), semanticObject.getLeft());
		feeder.accept(grammarAccess.getExpAccess().getRightMulDivParserRuleCall_1_1_0(), semanticObject.getRight());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     LogicExp.Equals_1_0_0 returns Plus
	 *     LogicExp.LessThan_1_1_0 returns Plus
	 *     LogicExp.GreaterThan_1_2_0 returns Plus
	 *     LogicExp.LessThanOrEquals_1_3_0 returns Plus
	 *     LogicExp.GreaterThanOrEquals_1_4_0 returns Plus
	 *     Exp returns Plus
	 *     Exp.Plus_1_0_0_0 returns Plus
	 *     Exp.Minus_1_0_1 returns Plus
	 *
	 * Constraint:
	 *     (left=Exp_Plus_1_0_0_0 right=MulDiv)
	 * </pre>
	 */
	protected void sequence_Exp(ISerializationContext context, Plus semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, X21Package.Literals.PLUS__LEFT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, X21Package.Literals.PLUS__LEFT));
			if (transientValues.isValueTransient(semanticObject, X21Package.Literals.PLUS__RIGHT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, X21Package.Literals.PLUS__RIGHT));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getExpAccess().getPlusLeftAction_1_0_0_0(), semanticObject.getLeft());
		feeder.accept(grammarAccess.getExpAccess().getRightMulDivParserRuleCall_1_1_0(), semanticObject.getRight());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     FunctionOrLambda returns FunctionReference
	 *
	 * Constraint:
	 *     ref=[Function|ID]
	 * </pre>
	 */
	protected void sequence_FunctionOrLambda(ISerializationContext context, FunctionReference semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, X21Package.Literals.FUNCTION_REFERENCE__REF) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, X21Package.Literals.FUNCTION_REFERENCE__REF));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getFunctionOrLambdaAccess().getRefFunctionIDTerminalRuleCall_1_0_1_0_1(), semanticObject.eGet(X21Package.Literals.FUNCTION_REFERENCE__REF, false));
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Declaration returns Function
	 *     Function returns Function
	 *
	 * Constraint:
	 *     (name=ID body=Lambda)
	 * </pre>
	 */
	protected void sequence_Function(ISerializationContext context, Function semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, X21Package.Literals.FUNCTION__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, X21Package.Literals.FUNCTION__NAME));
			if (transientValues.isValueTransient(semanticObject, X21Package.Literals.FUNCTION__BODY) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, X21Package.Literals.FUNCTION__BODY));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getFunctionAccess().getNameIDTerminalRuleCall_1_0(), semanticObject.getName());
		feeder.accept(grammarAccess.getFunctionAccess().getBodyLambdaParserRuleCall_2_0(), semanticObject.getBody());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     LogicExp.Equals_1_0_0 returns IfStatement
	 *     LogicExp.LessThan_1_1_0 returns IfStatement
	 *     LogicExp.GreaterThan_1_2_0 returns IfStatement
	 *     LogicExp.LessThanOrEquals_1_3_0 returns IfStatement
	 *     LogicExp.GreaterThanOrEquals_1_4_0 returns IfStatement
	 *     Exp returns IfStatement
	 *     Exp.Plus_1_0_0_0 returns IfStatement
	 *     Exp.Minus_1_0_1 returns IfStatement
	 *     MulDiv returns IfStatement
	 *     MulDiv.Mul_1_0_0_0 returns IfStatement
	 *     MulDiv.Div_1_0_1_0 returns IfStatement
	 *     Primary returns IfStatement
	 *     IfStatement returns IfStatement
	 *
	 * Constraint:
	 *     (condition=LogicExp trueExp=Exp falseExp=Exp)
	 * </pre>
	 */
	protected void sequence_IfStatement(ISerializationContext context, IfStatement semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, X21Package.Literals.IF_STATEMENT__CONDITION) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, X21Package.Literals.IF_STATEMENT__CONDITION));
			if (transientValues.isValueTransient(semanticObject, X21Package.Literals.IF_STATEMENT__TRUE_EXP) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, X21Package.Literals.IF_STATEMENT__TRUE_EXP));
			if (transientValues.isValueTransient(semanticObject, X21Package.Literals.IF_STATEMENT__FALSE_EXP) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, X21Package.Literals.IF_STATEMENT__FALSE_EXP));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getIfStatementAccess().getConditionLogicExpParserRuleCall_1_0(), semanticObject.getCondition());
		feeder.accept(grammarAccess.getIfStatementAccess().getTrueExpExpParserRuleCall_3_0(), semanticObject.getTrueExp());
		feeder.accept(grammarAccess.getIfStatementAccess().getFalseExpExpParserRuleCall_5_0(), semanticObject.getFalseExp());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Lambda returns Lambda
	 *     FunctionOrLambda returns Lambda
	 *     DataRef returns Lambda
	 *
	 * Constraint:
	 *     (name=ID type=Type logic=Exp)
	 * </pre>
	 */
	protected void sequence_Lambda_NameAndType(ISerializationContext context, Lambda semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, X21Package.Literals.NAME_AND_TYPE__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, X21Package.Literals.NAME_AND_TYPE__NAME));
			if (transientValues.isValueTransient(semanticObject, X21Package.Literals.NAME_AND_TYPE__TYPE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, X21Package.Literals.NAME_AND_TYPE__TYPE));
			if (transientValues.isValueTransient(semanticObject, X21Package.Literals.LAMBDA__LOGIC) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, X21Package.Literals.LAMBDA__LOGIC));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getNameAndTypeAccess().getNameIDTerminalRuleCall_0_0(), semanticObject.getName());
		feeder.accept(grammarAccess.getNameAndTypeAccess().getTypeTypeParserRuleCall_2_0(), semanticObject.getType());
		feeder.accept(grammarAccess.getLambdaAccess().getLogicExpParserRuleCall_4_0(), semanticObject.getLogic());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     LogicExp.Equals_1_0_0 returns LetStatement
	 *     LogicExp.LessThan_1_1_0 returns LetStatement
	 *     LogicExp.GreaterThan_1_2_0 returns LetStatement
	 *     LogicExp.LessThanOrEquals_1_3_0 returns LetStatement
	 *     LogicExp.GreaterThanOrEquals_1_4_0 returns LetStatement
	 *     Exp returns LetStatement
	 *     Exp.Plus_1_0_0_0 returns LetStatement
	 *     Exp.Minus_1_0_1 returns LetStatement
	 *     MulDiv returns LetStatement
	 *     MulDiv.Mul_1_0_0_0 returns LetStatement
	 *     MulDiv.Div_1_0_1_0 returns LetStatement
	 *     Primary returns LetStatement
	 *     LetStatement returns LetStatement
	 *     DataRef returns LetStatement
	 *
	 * Constraint:
	 *     (name=ID value=Exp body=Exp)
	 * </pre>
	 */
	protected void sequence_LetStatement(ISerializationContext context, LetStatement semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, X21Package.Literals.LET_STATEMENT__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, X21Package.Literals.LET_STATEMENT__NAME));
			if (transientValues.isValueTransient(semanticObject, X21Package.Literals.LET_STATEMENT__VALUE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, X21Package.Literals.LET_STATEMENT__VALUE));
			if (transientValues.isValueTransient(semanticObject, X21Package.Literals.LET_STATEMENT__BODY) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, X21Package.Literals.LET_STATEMENT__BODY));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getLetStatementAccess().getNameIDTerminalRuleCall_1_0(), semanticObject.getName());
		feeder.accept(grammarAccess.getLetStatementAccess().getValueExpParserRuleCall_3_0(), semanticObject.getValue());
		feeder.accept(grammarAccess.getLetStatementAccess().getBodyExpParserRuleCall_5_0(), semanticObject.getBody());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     LogicExp returns Equals
	 *
	 * Constraint:
	 *     (left=LogicExp_Equals_1_0_0 right=Exp)
	 * </pre>
	 */
	protected void sequence_LogicExp(ISerializationContext context, Equals semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, X21Package.Literals.EQUALS__LEFT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, X21Package.Literals.EQUALS__LEFT));
			if (transientValues.isValueTransient(semanticObject, X21Package.Literals.EQUALS__RIGHT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, X21Package.Literals.EQUALS__RIGHT));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getLogicExpAccess().getEqualsLeftAction_1_0_0(), semanticObject.getLeft());
		feeder.accept(grammarAccess.getLogicExpAccess().getRightExpParserRuleCall_2_0(), semanticObject.getRight());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     LogicExp returns GreaterThan
	 *
	 * Constraint:
	 *     (left=LogicExp_GreaterThan_1_2_0 right=Exp)
	 * </pre>
	 */
	protected void sequence_LogicExp(ISerializationContext context, GreaterThan semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, X21Package.Literals.GREATER_THAN__LEFT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, X21Package.Literals.GREATER_THAN__LEFT));
			if (transientValues.isValueTransient(semanticObject, X21Package.Literals.GREATER_THAN__RIGHT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, X21Package.Literals.GREATER_THAN__RIGHT));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getLogicExpAccess().getGreaterThanLeftAction_1_2_0(), semanticObject.getLeft());
		feeder.accept(grammarAccess.getLogicExpAccess().getRightExpParserRuleCall_2_0(), semanticObject.getRight());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     LogicExp returns GreaterThanOrEquals
	 *
	 * Constraint:
	 *     (left=LogicExp_GreaterThanOrEquals_1_4_0 right=Exp)
	 * </pre>
	 */
	protected void sequence_LogicExp(ISerializationContext context, GreaterThanOrEquals semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, X21Package.Literals.GREATER_THAN_OR_EQUALS__LEFT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, X21Package.Literals.GREATER_THAN_OR_EQUALS__LEFT));
			if (transientValues.isValueTransient(semanticObject, X21Package.Literals.GREATER_THAN_OR_EQUALS__RIGHT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, X21Package.Literals.GREATER_THAN_OR_EQUALS__RIGHT));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getLogicExpAccess().getGreaterThanOrEqualsLeftAction_1_4_0(), semanticObject.getLeft());
		feeder.accept(grammarAccess.getLogicExpAccess().getRightExpParserRuleCall_2_0(), semanticObject.getRight());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     LogicExp returns LessThan
	 *
	 * Constraint:
	 *     (left=LogicExp_LessThan_1_1_0 right=Exp)
	 * </pre>
	 */
	protected void sequence_LogicExp(ISerializationContext context, LessThan semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, X21Package.Literals.LESS_THAN__LEFT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, X21Package.Literals.LESS_THAN__LEFT));
			if (transientValues.isValueTransient(semanticObject, X21Package.Literals.LESS_THAN__RIGHT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, X21Package.Literals.LESS_THAN__RIGHT));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getLogicExpAccess().getLessThanLeftAction_1_1_0(), semanticObject.getLeft());
		feeder.accept(grammarAccess.getLogicExpAccess().getRightExpParserRuleCall_2_0(), semanticObject.getRight());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     LogicExp returns LessThanOrEquals
	 *
	 * Constraint:
	 *     (left=LogicExp_LessThanOrEquals_1_3_0 right=Exp)
	 * </pre>
	 */
	protected void sequence_LogicExp(ISerializationContext context, LessThanOrEquals semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, X21Package.Literals.LESS_THAN_OR_EQUALS__LEFT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, X21Package.Literals.LESS_THAN_OR_EQUALS__LEFT));
			if (transientValues.isValueTransient(semanticObject, X21Package.Literals.LESS_THAN_OR_EQUALS__RIGHT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, X21Package.Literals.LESS_THAN_OR_EQUALS__RIGHT));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getLogicExpAccess().getLessThanOrEqualsLeftAction_1_3_0(), semanticObject.getLeft());
		feeder.accept(grammarAccess.getLogicExpAccess().getRightExpParserRuleCall_2_0(), semanticObject.getRight());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     LogicExp.Equals_1_0_0 returns Div
	 *     LogicExp.LessThan_1_1_0 returns Div
	 *     LogicExp.GreaterThan_1_2_0 returns Div
	 *     LogicExp.LessThanOrEquals_1_3_0 returns Div
	 *     LogicExp.GreaterThanOrEquals_1_4_0 returns Div
	 *     Exp returns Div
	 *     Exp.Plus_1_0_0_0 returns Div
	 *     Exp.Minus_1_0_1 returns Div
	 *     MulDiv returns Div
	 *     MulDiv.Mul_1_0_0_0 returns Div
	 *     MulDiv.Div_1_0_1_0 returns Div
	 *
	 * Constraint:
	 *     (left=MulDiv_Div_1_0_1_0 right=Primary)
	 * </pre>
	 */
	protected void sequence_MulDiv(ISerializationContext context, Div semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, X21Package.Literals.DIV__LEFT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, X21Package.Literals.DIV__LEFT));
			if (transientValues.isValueTransient(semanticObject, X21Package.Literals.DIV__RIGHT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, X21Package.Literals.DIV__RIGHT));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getMulDivAccess().getDivLeftAction_1_0_1_0(), semanticObject.getLeft());
		feeder.accept(grammarAccess.getMulDivAccess().getRightPrimaryParserRuleCall_1_1_0(), semanticObject.getRight());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     LogicExp.Equals_1_0_0 returns Mul
	 *     LogicExp.LessThan_1_1_0 returns Mul
	 *     LogicExp.GreaterThan_1_2_0 returns Mul
	 *     LogicExp.LessThanOrEquals_1_3_0 returns Mul
	 *     LogicExp.GreaterThanOrEquals_1_4_0 returns Mul
	 *     Exp returns Mul
	 *     Exp.Plus_1_0_0_0 returns Mul
	 *     Exp.Minus_1_0_1 returns Mul
	 *     MulDiv returns Mul
	 *     MulDiv.Mul_1_0_0_0 returns Mul
	 *     MulDiv.Div_1_0_1_0 returns Mul
	 *
	 * Constraint:
	 *     (left=MulDiv_Mul_1_0_0_0 right=Primary)
	 * </pre>
	 */
	protected void sequence_MulDiv(ISerializationContext context, Mul semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, X21Package.Literals.MUL__LEFT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, X21Package.Literals.MUL__LEFT));
			if (transientValues.isValueTransient(semanticObject, X21Package.Literals.MUL__RIGHT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, X21Package.Literals.MUL__RIGHT));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getMulDivAccess().getMulLeftAction_1_0_0_0(), semanticObject.getLeft());
		feeder.accept(grammarAccess.getMulDivAccess().getRightPrimaryParserRuleCall_1_1_0(), semanticObject.getRight());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Declaration returns Input
	 *     Input returns Input
	 *     NodeOrInput returns Input
	 *
	 * Constraint:
	 *     (name=ID type=Type)
	 * </pre>
	 */
	protected void sequence_NameAndType(ISerializationContext context, Input semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, X21Package.Literals.NAME_AND_TYPE__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, X21Package.Literals.NAME_AND_TYPE__NAME));
			if (transientValues.isValueTransient(semanticObject, X21Package.Literals.NAME_AND_TYPE__TYPE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, X21Package.Literals.NAME_AND_TYPE__TYPE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getNameAndTypeAccess().getNameIDTerminalRuleCall_0_0(), semanticObject.getName());
		feeder.accept(grammarAccess.getNameAndTypeAccess().getTypeTypeParserRuleCall_2_0(), semanticObject.getType());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Declaration returns Parameter
	 *     Parameter returns Parameter
	 *     DataRef returns Parameter
	 *
	 * Constraint:
	 *     (name=ID type=Type)
	 * </pre>
	 */
	protected void sequence_NameAndType(ISerializationContext context, dk.sdu.mmmi.mdsd.x21.Parameter semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, X21Package.Literals.NAME_AND_TYPE__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, X21Package.Literals.NAME_AND_TYPE__NAME));
			if (transientValues.isValueTransient(semanticObject, X21Package.Literals.NAME_AND_TYPE__TYPE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, X21Package.Literals.NAME_AND_TYPE__TYPE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getNameAndTypeAccess().getNameIDTerminalRuleCall_0_0(), semanticObject.getName());
		feeder.accept(grammarAccess.getNameAndTypeAccess().getTypeTypeParserRuleCall_2_0(), semanticObject.getType());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     LogicExp.Equals_1_0_0 returns NewStatement
	 *     LogicExp.LessThan_1_1_0 returns NewStatement
	 *     LogicExp.GreaterThan_1_2_0 returns NewStatement
	 *     LogicExp.LessThanOrEquals_1_3_0 returns NewStatement
	 *     LogicExp.GreaterThanOrEquals_1_4_0 returns NewStatement
	 *     Exp returns NewStatement
	 *     Exp.Plus_1_0_0_0 returns NewStatement
	 *     Exp.Minus_1_0_1 returns NewStatement
	 *     MulDiv returns NewStatement
	 *     MulDiv.Mul_1_0_0_0 returns NewStatement
	 *     MulDiv.Div_1_0_1_0 returns NewStatement
	 *     Primary returns NewStatement
	 *     NewStatement returns NewStatement
	 *
	 * Constraint:
	 *     (type=DataDecl variables+=VarAssignment variables+=VarAssignment*)
	 * </pre>
	 */
	protected void sequence_NewStatement(ISerializationContext context, NewStatement semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Declaration returns Node
	 *     Node returns Node
	 *     NodeOrInput returns Node
	 *
	 * Constraint:
	 *     (name=ID body=FunctionOrLambda)
	 * </pre>
	 */
	protected void sequence_Node(ISerializationContext context, Node semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, X21Package.Literals.NODE__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, X21Package.Literals.NODE__NAME));
			if (transientValues.isValueTransient(semanticObject, X21Package.Literals.NODE__BODY) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, X21Package.Literals.NODE__BODY));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getNodeAccess().getNameIDTerminalRuleCall_1_0(), semanticObject.getName());
		feeder.accept(grammarAccess.getNodeAccess().getBodyFunctionOrLambdaParserRuleCall_2_0(), semanticObject.getBody());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     LogicExp.Equals_1_0_0 returns None
	 *     LogicExp.LessThan_1_1_0 returns None
	 *     LogicExp.GreaterThan_1_2_0 returns None
	 *     LogicExp.LessThanOrEquals_1_3_0 returns None
	 *     LogicExp.GreaterThanOrEquals_1_4_0 returns None
	 *     Exp returns None
	 *     Exp.Plus_1_0_0_0 returns None
	 *     Exp.Minus_1_0_1 returns None
	 *     MulDiv returns None
	 *     MulDiv.Mul_1_0_0_0 returns None
	 *     MulDiv.Div_1_0_1_0 returns None
	 *     Primary returns None
	 *     None returns None
	 *
	 * Constraint:
	 *     {None}
	 * </pre>
	 */
	protected void sequence_None(ISerializationContext context, None semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     LogicExp.Equals_1_0_0 returns Int
	 *     LogicExp.LessThan_1_1_0 returns Int
	 *     LogicExp.GreaterThan_1_2_0 returns Int
	 *     LogicExp.LessThanOrEquals_1_3_0 returns Int
	 *     LogicExp.GreaterThanOrEquals_1_4_0 returns Int
	 *     Exp returns Int
	 *     Exp.Plus_1_0_0_0 returns Int
	 *     Exp.Minus_1_0_1 returns Int
	 *     MulDiv returns Int
	 *     MulDiv.Mul_1_0_0_0 returns Int
	 *     MulDiv.Div_1_0_1_0 returns Int
	 *     Primary returns Int
	 *
	 * Constraint:
	 *     value=INT
	 * </pre>
	 */
	protected void sequence_Primary(ISerializationContext context, Int semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, X21Package.Literals.INT__VALUE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, X21Package.Literals.INT__VALUE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getPrimaryAccess().getValueINTTerminalRuleCall_0_1_0(), semanticObject.getValue());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     LogicExp.Equals_1_0_0 returns Parenthesis
	 *     LogicExp.LessThan_1_1_0 returns Parenthesis
	 *     LogicExp.GreaterThan_1_2_0 returns Parenthesis
	 *     LogicExp.LessThanOrEquals_1_3_0 returns Parenthesis
	 *     LogicExp.GreaterThanOrEquals_1_4_0 returns Parenthesis
	 *     Exp returns Parenthesis
	 *     Exp.Plus_1_0_0_0 returns Parenthesis
	 *     Exp.Minus_1_0_1 returns Parenthesis
	 *     MulDiv returns Parenthesis
	 *     MulDiv.Mul_1_0_0_0 returns Parenthesis
	 *     MulDiv.Div_1_0_1_0 returns Parenthesis
	 *     Primary returns Parenthesis
	 *
	 * Constraint:
	 *     body=Exp
	 * </pre>
	 */
	protected void sequence_Primary(ISerializationContext context, Parenthesis semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, X21Package.Literals.PARENTHESIS__BODY) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, X21Package.Literals.PARENTHESIS__BODY));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getPrimaryAccess().getBodyExpParserRuleCall_1_2_0(), semanticObject.getBody());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Declaration returns Stream
	 *     Stream returns Stream
	 *
	 * Constraint:
	 *     (startNodes+=NodeOrInput startNodes+=NodeOrInput* points+=ElementList+)
	 * </pre>
	 */
	protected void sequence_Stream(ISerializationContext context, Stream semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Type returns CustomType
	 *
	 * Constraint:
	 *     ref=[DataDecl|ID]
	 * </pre>
	 */
	protected void sequence_Type(ISerializationContext context, CustomType semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, X21Package.Literals.CUSTOM_TYPE__REF) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, X21Package.Literals.CUSTOM_TYPE__REF));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getTypeAccess().getRefDataDeclIDTerminalRuleCall_2_1_0_1(), semanticObject.eGet(X21Package.Literals.CUSTOM_TYPE__REF, false));
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Type returns IntType
	 *
	 * Constraint:
	 *     {IntType}
	 * </pre>
	 */
	protected void sequence_Type(ISerializationContext context, IntType semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Type returns StringType
	 *
	 * Constraint:
	 *     {StringType}
	 * </pre>
	 */
	protected void sequence_Type(ISerializationContext context, StringType semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     VarAssignment returns VarAssignment
	 *
	 * Constraint:
	 *     (variable=[DataVariable|ID] value=Exp)
	 * </pre>
	 */
	protected void sequence_VarAssignment(ISerializationContext context, VarAssignment semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, X21Package.Literals.VAR_ASSIGNMENT__VARIABLE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, X21Package.Literals.VAR_ASSIGNMENT__VARIABLE));
			if (transientValues.isValueTransient(semanticObject, X21Package.Literals.VAR_ASSIGNMENT__VALUE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, X21Package.Literals.VAR_ASSIGNMENT__VALUE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getVarAssignmentAccess().getVariableDataVariableIDTerminalRuleCall_0_0_1(), semanticObject.eGet(X21Package.Literals.VAR_ASSIGNMENT__VARIABLE, false));
		feeder.accept(grammarAccess.getVarAssignmentAccess().getValueExpParserRuleCall_2_0(), semanticObject.getValue());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     X21 returns X21
	 *
	 * Constraint:
	 *     declarations+=Declaration*
	 * </pre>
	 */
	protected void sequence_X21(ISerializationContext context, X21 semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
}
