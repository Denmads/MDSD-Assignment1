/**
 * generated by Xtext 2.25.0
 */
package dk.sdu.mmmi.mdsd.generator;

import com.google.common.collect.Iterators;
import dk.sdu.mmmi.mdsd.math.Atomic;
import dk.sdu.mmmi.mdsd.math.Div;
import dk.sdu.mmmi.mdsd.math.Expression;
import dk.sdu.mmmi.mdsd.math.LocalVariable;
import dk.sdu.mmmi.mdsd.math.MathScript;
import dk.sdu.mmmi.mdsd.math.Minus;
import dk.sdu.mmmi.mdsd.math.Mult;
import dk.sdu.mmmi.mdsd.math.Plus;
import dk.sdu.mmmi.mdsd.math.Statement;
import dk.sdu.mmmi.mdsd.math.VariableRef;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.Iterator;
import java.util.List;
import java.util.Map;
import java.util.Set;
import java.util.function.BiConsumer;
import javax.swing.JOptionPane;
import org.eclipse.emf.common.util.EList;
import org.eclipse.emf.ecore.EObject;
import org.eclipse.emf.ecore.resource.Resource;
import org.eclipse.xtext.generator.AbstractGenerator;
import org.eclipse.xtext.generator.IFileSystemAccess2;
import org.eclipse.xtext.generator.IGeneratorContext;
import org.eclipse.xtext.xbase.lib.CollectionLiterals;
import org.eclipse.xtext.xbase.lib.Functions.Function1;
import org.eclipse.xtext.xbase.lib.ListExtensions;

/**
 * Generates code from your model files on save.
 * 
 * See https://www.eclipse.org/Xtext/documentation/303_runtime_concepts.html#code-generation
 */
@SuppressWarnings("all")
public class MathGenerator extends AbstractGenerator {
  @Override
  public void doGenerate(final Resource resource, final IFileSystemAccess2 fsa, final IGeneratorContext context) {
    final Iterator<MathScript> mathIter = Iterators.<MathScript>filter(resource.getAllContents(), MathScript.class);
    boolean _hasNext = mathIter.hasNext();
    if (_hasNext) {
      final MathScript math = mathIter.next();
      final HashMap<String, Integer> result = MathGenerator.compute(math);
      this.displayPanel(result);
    }
  }
  
  public static HashMap<String, Integer> compute(final MathScript math) {
    final HashMap<String, Integer> variables = new HashMap<String, Integer>();
    EList<Statement> _statements = math.getStatements();
    final ArrayList<Statement> statements = new ArrayList<Statement>(_statements);
    int _size = statements.size();
    int index = (_size - 1);
    while ((statements.size() > 0)) {
      {
        Statement stmt = statements.get(index);
        boolean _requirementsFullfilled = MathGenerator.requirementsFullfilled(stmt, math, variables);
        if (_requirementsFullfilled) {
          final int result = MathGenerator.compute(stmt.getExp(), MathGenerator.cloneMap(variables));
          variables.put(stmt.getName(), Integer.valueOf(result));
          statements.remove(index);
        }
        index--;
        if ((index < 0)) {
          int _index = index;
          int _size_1 = statements.size();
          index = (_index + _size_1);
        }
      }
    }
    return variables;
  }
  
  public static Map<String, Integer> cloneMap(final Map<String, Integer> source) {
    final HashMap<String, Integer> newMap = CollectionLiterals.<String, Integer>newHashMap();
    final BiConsumer<String, Integer> _function = (String key, Integer value) -> {
      newMap.put(key, value);
    };
    source.forEach(_function);
    return newMap;
  }
  
  public static boolean requirementsFullfilled(final Statement stmt, final MathScript ms, final Map<String, Integer> calculatedVars) {
    final Function1<Statement, String> _function = (Statement it) -> {
      return it.getName();
    };
    final List<String> required = MathGenerator.requiredGlobalVars(stmt, ListExtensions.<Statement, String>map(ms.getStatements(), _function));
    for (final String s : required) {
      boolean _containsKey = calculatedVars.containsKey(s);
      boolean _not = (!_containsKey);
      if (_not) {
        return false;
      }
    }
    return true;
  }
  
  public static List<String> requiredGlobalVars(final Statement stmt, final List<String> allGlobals) {
    final ArrayList<String> vars = CollectionLiterals.<String>newArrayList();
    final Set<String> refs = MathGenerator.getReqVars(stmt, CollectionLiterals.<String>newHashSet());
    for (final String v : refs) {
      boolean _contains = allGlobals.contains(v);
      if (_contains) {
        vars.add(v);
      }
    }
    return vars;
  }
  
  public static Set<String> getReqVars(final EObject obj, final Set<String> vars) {
    boolean _matched = false;
    if (obj instanceof Statement) {
      _matched=true;
      MathGenerator.getReqVars(((Statement)obj).getExp(), vars);
    }
    if (!_matched) {
      if (obj instanceof Plus) {
        _matched=true;
        MathGenerator.getReqVars(((Plus)obj).getLeft(), vars);
        MathGenerator.getReqVars(((Plus)obj).getRight(), vars);
      }
    }
    if (!_matched) {
      if (obj instanceof Minus) {
        _matched=true;
        MathGenerator.getReqVars(((Minus)obj).getLeft(), vars);
        MathGenerator.getReqVars(((Minus)obj).getRight(), vars);
      }
    }
    if (!_matched) {
      if (obj instanceof Mult) {
        _matched=true;
        MathGenerator.getReqVars(((Mult)obj).getLeft(), vars);
        MathGenerator.getReqVars(((Mult)obj).getRight(), vars);
      }
    }
    if (!_matched) {
      if (obj instanceof Div) {
        _matched=true;
        MathGenerator.getReqVars(((Div)obj).getLeft(), vars);
        MathGenerator.getReqVars(((Div)obj).getRight(), vars);
      }
    }
    if (!_matched) {
      if (obj instanceof LocalVariable) {
        _matched=true;
        MathGenerator.getReqVars(((LocalVariable)obj).getValExp(), vars);
        MathGenerator.getReqVars(((LocalVariable)obj).getExp(), vars);
      }
    }
    if (!_matched) {
      if (obj instanceof Atomic) {
        _matched=true;
        MathGenerator.getReqVars(((Atomic)obj), vars);
      }
    }
    return vars;
  }
  
  public static Set<String> getReqVars(final Atomic obj, final Set<String> vars) {
    if ((obj instanceof VariableRef)) {
      vars.add(((VariableRef)obj).getValue().getName());
    }
    return vars;
  }
  
  public static int compute(final Expression exp, final Map<String, Integer> vars) {
    int _switchResult = (int) 0;
    boolean _matched = false;
    if (exp instanceof Plus) {
      _matched=true;
      _switchResult = MathGenerator.compute(((Plus)exp), vars);
    }
    if (!_matched) {
      if (exp instanceof Minus) {
        _matched=true;
        _switchResult = MathGenerator.compute(((Minus)exp), vars);
      }
    }
    if (!_matched) {
      if (exp instanceof Mult) {
        _matched=true;
        _switchResult = MathGenerator.compute(((Mult)exp), vars);
      }
    }
    if (!_matched) {
      if (exp instanceof Div) {
        _matched=true;
        _switchResult = MathGenerator.compute(((Div)exp), vars);
      }
    }
    if (!_matched) {
      if (exp instanceof LocalVariable) {
        _matched=true;
        _switchResult = MathGenerator.compute(((LocalVariable)exp), vars);
      }
    }
    if (!_matched) {
      if (exp instanceof Atomic) {
        _matched=true;
        _switchResult = MathGenerator.compute(((Atomic)exp), vars);
      }
    }
    return _switchResult;
  }
  
  public static int compute(final Plus exp, final Map<String, Integer> vars) {
    int _compute = MathGenerator.compute(exp.getLeft(), vars);
    int _compute_1 = MathGenerator.compute(exp.getRight(), vars);
    return (_compute + _compute_1);
  }
  
  public static int compute(final Minus exp, final Map<String, Integer> vars) {
    int _compute = MathGenerator.compute(exp.getLeft(), vars);
    int _compute_1 = MathGenerator.compute(exp.getRight(), vars);
    return (_compute - _compute_1);
  }
  
  public static int compute(final Mult exp, final Map<String, Integer> vars) {
    int _compute = MathGenerator.compute(exp.getLeft(), vars);
    int _compute_1 = MathGenerator.compute(exp.getRight(), vars);
    return (_compute * _compute_1);
  }
  
  public static int compute(final Div exp, final Map<String, Integer> vars) {
    int _compute = MathGenerator.compute(exp.getLeft(), vars);
    int _compute_1 = MathGenerator.compute(exp.getRight(), vars);
    int _divide = (_compute / _compute_1);
    double _floor = Math.floor(_divide);
    return ((int) _floor);
  }
  
  public static int compute(final LocalVariable exp, final Map<String, Integer> vars) {
    final Integer prevVal = vars.get(exp.getName());
    final int varVal = MathGenerator.compute(exp.getValExp(), vars);
    vars.put(exp.getName(), Integer.valueOf(varVal));
    final int res = MathGenerator.compute(exp.getExp(), vars);
    if ((prevVal != null)) {
      vars.put(exp.getName(), prevVal);
    }
    return res;
  }
  
  public static int compute(final Atomic exp, final Map<String, Integer> vars) {
    int _switchResult = (int) 0;
    boolean _matched = false;
    if (exp instanceof dk.sdu.mmmi.mdsd.math.Number) {
      _matched=true;
      _switchResult = ((dk.sdu.mmmi.mdsd.math.Number) exp).getValue();
    }
    if (!_matched) {
      if (exp instanceof VariableRef) {
        _matched=true;
        _switchResult = MathGenerator.compute(((VariableRef)exp), vars);
      }
    }
    return _switchResult;
  }
  
  public static int compute(final VariableRef exp, final Map<String, Integer> vars) {
    final String name = exp.getValue().getName();
    return (vars.get(name)).intValue();
  }
  
  public void displayPanel(final Map<String, Integer> result) {
    String resultString = "";
    Set<Map.Entry<String, Integer>> _entrySet = result.entrySet();
    for (final Map.Entry<String, Integer> entry : _entrySet) {
      String _resultString = resultString;
      String _key = entry.getKey();
      String _plus = ("var " + _key);
      String _plus_1 = (_plus + " = ");
      Integer _value = entry.getValue();
      String _plus_2 = (_plus_1 + _value);
      String _plus_3 = (_plus_2 + "\n");
      resultString = (_resultString + _plus_3);
    }
    JOptionPane.showMessageDialog(null, resultString, "Math Language", JOptionPane.INFORMATION_MESSAGE);
  }
}
