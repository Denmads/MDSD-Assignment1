/**
 * generated by Xtext 2.26.0
 */
package dk.sdu.mmmi.mdsd.validation;

import com.google.common.base.Objects;
import com.google.common.collect.Iterables;
import com.google.common.collect.Iterators;
import dk.sdu.mmmi.mdsd.generator.Util;
import dk.sdu.mmmi.mdsd.generator.typing.ExpType;
import dk.sdu.mmmi.mdsd.generator.typing.TypeComputer;
import dk.sdu.mmmi.mdsd.iF22.Add;
import dk.sdu.mmmi.mdsd.iF22.And;
import dk.sdu.mmmi.mdsd.iF22.Concatenation;
import dk.sdu.mmmi.mdsd.iF22.Div;
import dk.sdu.mmmi.mdsd.iF22.End;
import dk.sdu.mmmi.mdsd.iF22.Equals;
import dk.sdu.mmmi.mdsd.iF22.Exp;
import dk.sdu.mmmi.mdsd.iF22.Function;
import dk.sdu.mmmi.mdsd.iF22.FunctionCall;
import dk.sdu.mmmi.mdsd.iF22.GreaterThan;
import dk.sdu.mmmi.mdsd.iF22.GreaterThanOrEquals;
import dk.sdu.mmmi.mdsd.iF22.IF22;
import dk.sdu.mmmi.mdsd.iF22.IF22Package;
import dk.sdu.mmmi.mdsd.iF22.LessThan;
import dk.sdu.mmmi.mdsd.iF22.LessThanOrEquals;
import dk.sdu.mmmi.mdsd.iF22.Mul;
import dk.sdu.mmmi.mdsd.iF22.Not;
import dk.sdu.mmmi.mdsd.iF22.NotEquals;
import dk.sdu.mmmi.mdsd.iF22.Or;
import dk.sdu.mmmi.mdsd.iF22.Parameter;
import dk.sdu.mmmi.mdsd.iF22.Question;
import dk.sdu.mmmi.mdsd.iF22.Scenario;
import dk.sdu.mmmi.mdsd.iF22.Statement;
import dk.sdu.mmmi.mdsd.iF22.Sub;
import dk.sdu.mmmi.mdsd.iF22.Target;
import dk.sdu.mmmi.mdsd.iF22.TargetDestination;
import dk.sdu.mmmi.mdsd.iF22.This;
import dk.sdu.mmmi.mdsd.iF22.Type;
import javax.inject.Inject;
import org.eclipse.emf.common.util.EList;
import org.eclipse.emf.ecore.EObject;
import org.eclipse.emf.ecore.EReference;
import org.eclipse.xtend2.lib.StringConcatenation;
import org.eclipse.xtext.validation.Check;
import org.eclipse.xtext.xbase.lib.Extension;
import org.eclipse.xtext.xbase.lib.Functions.Function1;
import org.eclipse.xtext.xbase.lib.IterableExtensions;
import org.eclipse.xtext.xbase.lib.IteratorExtensions;

/**
 * This class contains custom validation rules.
 * 
 * See https://www.eclipse.org/Xtext/documentation/303_runtime_concepts.html#validation
 */
@SuppressWarnings("all")
public class IF22Validator extends AbstractIF22Validator {
  public static final String DUPLICATE_SCENARIO_NAME = "dsn";
  
  public static final String DUPLICATE_FUNCTION_NAME = "dfn";
  
  public static final String DUPLICATE_STATEMENT_NAME = "dstn";
  
  public static final String NO_END_STATEMENT = "nos";
  
  public static final String INVALID_TYPE_USE = "itu";
  
  public static final String TOO_MANY_TYPE_KEYWORDS = "tmtk";
  
  public static final String INVALID_THIS_USE = "ithu";
  
  public static final String ILLEGAL_USE_OF_END_TARGETS = "iuoet";
  
  public static final String PARAMETER_NUMBER_MISMATCH = "pnm";
  
  public static final String PARAMETER_TYPE_MISMATCH = "ptm";
  
  public static final String VAR_TYPE_MISMATCH = "vtm";
  
  public static final String TYPE_MISMATCH = "tm";
  
  @Inject
  @Extension
  private TypeComputer _typeComputer;
  
  private void checkExpectedSame(final ExpType left, final ExpType right) {
    if ((((left != null) && (right != null)) && (left != right))) {
      StringConcatenation _builder = new StringConcatenation();
      _builder.append("Expected the same type but was ");
      _builder.append(left);
      _builder.append(", ");
      _builder.append(right);
      this.error(_builder.toString(), IF22Package.Literals.EQUALITY.getEIDAttribute(), IF22Validator.TYPE_MISMATCH);
    }
  }
  
  private void checkExpectedBoolean(final Exp exp, final EReference ref) {
    this.checkExpectedType(exp, TypeComputer.BOOL_TYPE, ref);
  }
  
  private void checkExpectedString(final Exp exp, final EReference ref) {
    this.checkExpectedType(exp, TypeComputer.STRING_TYPE, ref);
  }
  
  private void checkExpectedInt(final Exp exp, final EReference ref) {
    this.checkExpectedType(exp, TypeComputer.INT_TYPE, ref);
  }
  
  private void checkExpectedType(final Exp exp, final ExpType expectedType, final EReference ref) {
    final ExpType actualType = this.getTypeAndCheckNull(exp, ref);
    if ((actualType != expectedType)) {
      StringConcatenation _builder = new StringConcatenation();
      _builder.append("Expected ");
      _builder.append(expectedType);
      _builder.append(" type, but was ");
      _builder.append(actualType);
      this.error(_builder.toString(), ref, IF22Validator.TYPE_MISMATCH);
    }
  }
  
  private ExpType getTypeAndCheckNull(final Exp exp, final EReference ref) {
    ExpType _typeFor = null;
    if (exp!=null) {
      _typeFor=this._typeComputer.typeFor(exp);
    }
    ExpType type = _typeFor;
    if ((type == null)) {
      this.error("Null type", ref, IF22Validator.TYPE_MISMATCH);
    }
    return type;
  }
  
  @Check
  public void checkUniqueScenarioName(final Scenario scenario) {
    EObject _eContainer = scenario.eContainer();
    final Function1<Scenario, Boolean> _function = (Scenario it) -> {
      String _name = it.getName();
      String _name_1 = scenario.getName();
      return Boolean.valueOf(Objects.equal(_name, _name_1));
    };
    Iterable<Scenario> allOtherNames = IterableExtensions.<Scenario>filter(((IF22) _eContainer).getScenarios(), _function);
    int _size = IterableExtensions.size(allOtherNames);
    boolean _greaterThan = (_size > 1);
    if (_greaterThan) {
      this.error("Duplicate scenario name.", IF22Package.eINSTANCE.getTargetDestination_Name(), IF22Validator.DUPLICATE_SCENARIO_NAME);
    }
  }
  
  @Check
  public void checkUniqueFunctionName(final Function function) {
    EObject _eContainer = function.eContainer();
    final Function1<Function, Boolean> _function = (Function it) -> {
      String _name = it.getName();
      String _name_1 = function.getName();
      return Boolean.valueOf(Objects.equal(_name, _name_1));
    };
    Iterable<Function> allOtherNames = IterableExtensions.<Function>filter(((IF22) _eContainer).getFunctions(), _function);
    int _size = IterableExtensions.size(allOtherNames);
    boolean _greaterThan = (_size > 1);
    if (_greaterThan) {
      this.error("Duplicate function name.", IF22Package.eINSTANCE.getFunction_Name(), IF22Validator.DUPLICATE_FUNCTION_NAME);
    }
  }
  
  @Check
  public void checkUniqueStatementName(final Statement stmt) {
    EObject _eContainer = stmt.eContainer();
    final Function1<Statement, Boolean> _function = (Statement it) -> {
      String _name = it.getName();
      String _name_1 = stmt.getName();
      return Boolean.valueOf(Objects.equal(_name, _name_1));
    };
    Iterable<Statement> allOtherNames = IterableExtensions.<Statement>filter(Iterables.<Statement>filter(((Scenario) _eContainer).getBody(), Statement.class), _function);
    int _size = IterableExtensions.size(allOtherNames);
    boolean _greaterThan = (_size > 1);
    if (_greaterThan) {
      this.error("Duplicate statement name.", IF22Package.eINSTANCE.getTargetDestination_Name(), IF22Validator.DUPLICATE_STATEMENT_NAME);
    }
  }
  
  @Check
  public void checkAtLeastOneEndStatement(final Scenario scenario) {
    Iterable<End> endStatements = Iterables.<End>filter(scenario.getBody(), End.class);
    int _size = IterableExtensions.size(endStatements);
    boolean _equals = (_size == 0);
    if (_equals) {
      this.error("No end statement.", IF22Package.eINSTANCE.getTargetDestination_Name(), IF22Validator.NO_END_STATEMENT);
    }
  }
  
  public int getNumTypeUsed(final Exp exp) {
    if ((exp instanceof Type)) {
      return 1;
    } else {
      return IteratorExtensions.size(Iterators.<Type>filter(exp.eAllContents(), Type.class));
    }
  }
  
  public boolean containsThis(final Exp exp) {
    return ((exp instanceof This) || (IteratorExtensions.size(Iterators.<This>filter(exp.eAllContents(), This.class)) > 0));
  }
  
  @Check
  public void checkStatement(final Statement stmt) {
    if (((stmt.getBody() != null) && (this.getNumTypeUsed(stmt.getBody()) > 0))) {
      this.error("Types is not permitted in this context.", IF22Package.eINSTANCE.getStatement_Body(), IF22Validator.INVALID_TYPE_USE);
    }
    if (((!Objects.equal(stmt.getBody(), null)) && this.containsThis(stmt.getBody()))) {
      this.error("\'This\' is not permitted in this context.", IF22Package.eINSTANCE.getStatement_Body(), IF22Validator.INVALID_THIS_USE);
    }
  }
  
  @Check
  public void checkTarget(final Target target) {
    EList<Exp> _arguments = target.getArguments();
    for (final Exp arg : _arguments) {
      int _numTypeUsed = this.getNumTypeUsed(arg);
      boolean _greaterThan = (_numTypeUsed > 0);
      if (_greaterThan) {
        this.error("Types are not permitted in this context.", IF22Package.eINSTANCE.getTarget_Arguments(), IF22Validator.INVALID_TYPE_USE);
      }
    }
    if (((target.getCondition() != null) && (this.getNumTypeUsed(target.getCondition()) > 0))) {
      this.error("Types are not permitted in this context.", IF22Package.eINSTANCE.getTarget_Condition(), IF22Validator.INVALID_TYPE_USE);
    }
    if (((target.getEndTargets().size() > 0) && (target.getDestination() instanceof Statement))) {
      this.error("EndTargets is only allowed when the selected target is a scenario.", IF22Package.eINSTANCE.getTarget_EndTargets(), IF22Validator.ILLEGAL_USE_OF_END_TARGETS);
    }
    TargetDestination _destination = target.getDestination();
    if ((_destination instanceof Scenario)) {
      TargetDestination _destination_1 = target.getDestination();
      EList<Parameter> scenarioParams = ((Scenario) _destination_1).getParameters();
      int _size = scenarioParams.size();
      int _size_1 = target.getArguments().size();
      boolean _notEquals = (_size != _size_1);
      if (_notEquals) {
        this.error("Number of parameters and arguments are wrong.", IF22Package.eINSTANCE.getTarget_Arguments(), IF22Validator.PARAMETER_NUMBER_MISMATCH);
      }
      for (int i = 0; (i < scenarioParams.size()); i++) {
        ExpType _expType = this._typeComputer.toExpType(scenarioParams.get(i).getType());
        ExpType _typeFor = this._typeComputer.typeFor(target.getArguments().get(i));
        boolean _tripleNotEquals = (_expType != _typeFor);
        if (_tripleNotEquals) {
          this.error("Argument and paramter types are not matching.", IF22Package.eINSTANCE.getTarget_Arguments(), IF22Validator.PARAMETER_TYPE_MISMATCH);
        }
      }
    }
    Exp _condition = target.getCondition();
    boolean _tripleNotEquals = (_condition != null);
    if (_tripleNotEquals) {
      this.checkExpectedBoolean(target.getCondition(), IF22Package.Literals.TARGET__CONDITION);
    }
  }
  
  @Check
  public void checkQuestion(final Question stmt) {
    int _numTypeUsed = this.getNumTypeUsed(stmt.getTypeAndValidation());
    boolean _notEquals = (_numTypeUsed != 1);
    if (_notEquals) {
      this.error("There should be exactly one type in the expression.", IF22Package.eINSTANCE.getQuestion_TypeAndValidation(), IF22Validator.TOO_MANY_TYPE_KEYWORDS);
    }
    if (((stmt.getVariable() != null) && (!Util.toJavaType(Util.returnTypeOfQuestion(stmt)).equals(Util.toJavaType(stmt.getVariable().getType()))))) {
      this.error("Cannot assign different type to variable.", IF22Package.eINSTANCE.getQuestion_Variable(), IF22Validator.VAR_TYPE_MISMATCH);
    }
    Exp _typeAndValidation = stmt.getTypeAndValidation();
    boolean _not = (!(_typeAndValidation instanceof Type));
    if (_not) {
      this.checkExpectedBoolean(stmt.getTypeAndValidation(), IF22Package.Literals.QUESTION__TYPE_AND_VALIDATION);
    }
  }
  
  @Check
  public void checkFunctionCallParams(final FunctionCall fCall) {
    EList<Type> funcParams = fCall.getFunction().getParameterTypes();
    int _size = funcParams.size();
    int _size_1 = fCall.getArguments().size();
    boolean _notEquals = (_size != _size_1);
    if (_notEquals) {
      this.error("Number of parameters and arguments are wrong.", IF22Package.eINSTANCE.getFunctionCall_Arguments(), IF22Validator.PARAMETER_NUMBER_MISMATCH);
    }
    for (int i = 0; (i < funcParams.size()); i++) {
      ExpType _expType = this._typeComputer.toExpType(funcParams.get(i));
      ExpType _typeFor = this._typeComputer.typeFor(fCall.getArguments().get(i));
      boolean _tripleNotEquals = (_expType != _typeFor);
      if (_tripleNotEquals) {
        this.error("Argument and parameter types are not matching.", IF22Package.eINSTANCE.getFunctionCall_Arguments(), IF22Validator.PARAMETER_TYPE_MISMATCH);
      }
    }
  }
  
  @Check
  public void checkType(final Not not) {
    this.checkExpectedBoolean(not.getBody(), IF22Package.Literals.NOT__BODY);
  }
  
  @Check
  public void checkType(final Mul exp) {
    this.checkExpectedInt(exp.getLeft(), IF22Package.Literals.MUL__LEFT);
    this.checkExpectedInt(exp.getRight(), IF22Package.Literals.MUL__RIGHT);
  }
  
  @Check
  public void checkType(final Div exp) {
    this.checkExpectedInt(exp.getLeft(), IF22Package.Literals.DIV__LEFT);
    this.checkExpectedInt(exp.getRight(), IF22Package.Literals.DIV__RIGHT);
  }
  
  @Check
  public void checkType(final Add exp) {
    this.checkExpectedInt(exp.getLeft(), IF22Package.Literals.ADD__LEFT);
    this.checkExpectedInt(exp.getRight(), IF22Package.Literals.ADD__RIGHT);
  }
  
  @Check
  public void checkType(final Sub exp) {
    this.checkExpectedInt(exp.getLeft(), IF22Package.Literals.SUB__LEFT);
    this.checkExpectedInt(exp.getRight(), IF22Package.Literals.SUB__RIGHT);
  }
  
  @Check
  public void checkType(final Concatenation exp) {
    ExpType leftType = this.getTypeAndCheckNull(exp.getLeft(), IF22Package.Literals.CONCATENATION__LEFT);
    ExpType rightType = this.getTypeAndCheckNull(exp.getLeft(), IF22Package.Literals.CONCATENATION__RIGHT);
    if (((!this._typeComputer.isStringType(leftType)) && (!this._typeComputer.isStringType(rightType)))) {
      this.error("Concatenation expects at least one string.", IF22Package.Literals.CONCATENATION.getEIDAttribute(), IF22Validator.TYPE_MISMATCH);
    }
  }
  
  @Check
  public void checkType(final LessThan exp) {
    this.checkExpectedInt(exp.getLeft(), IF22Package.Literals.LESS_THAN__LEFT);
    this.checkExpectedInt(exp.getRight(), IF22Package.Literals.LESS_THAN__RIGHT);
  }
  
  @Check
  public void checkType(final GreaterThan exp) {
    this.checkExpectedInt(exp.getLeft(), IF22Package.Literals.GREATER_THAN__LEFT);
    this.checkExpectedInt(exp.getRight(), IF22Package.Literals.GREATER_THAN__RIGHT);
  }
  
  @Check
  public void checkType(final LessThanOrEquals exp) {
    this.checkExpectedInt(exp.getLeft(), IF22Package.Literals.LESS_THAN_OR_EQUALS__LEFT);
    this.checkExpectedInt(exp.getRight(), IF22Package.Literals.LESS_THAN_OR_EQUALS__RIGHT);
  }
  
  @Check
  public void checkType(final GreaterThanOrEquals exp) {
    this.checkExpectedInt(exp.getLeft(), IF22Package.Literals.GREATER_THAN_OR_EQUALS__LEFT);
    this.checkExpectedInt(exp.getRight(), IF22Package.Literals.GREATER_THAN_OR_EQUALS__RIGHT);
  }
  
  @Check
  public void checkType(final Equals exp) {
    ExpType leftType = this.getTypeAndCheckNull(exp.getLeft(), IF22Package.Literals.EQUALS__LEFT);
    ExpType rightType = this.getTypeAndCheckNull(exp.getLeft(), IF22Package.Literals.EQUALS__RIGHT);
    this.checkExpectedSame(leftType, rightType);
  }
  
  @Check
  public void checkType(final NotEquals exp) {
    ExpType leftType = this.getTypeAndCheckNull(exp.getLeft(), IF22Package.Literals.NOT_EQUALS__LEFT);
    ExpType rightType = this.getTypeAndCheckNull(exp.getLeft(), IF22Package.Literals.NOT_EQUALS__RIGHT);
    this.checkExpectedSame(leftType, rightType);
  }
  
  @Check
  public void checkType(final And exp) {
    this.checkExpectedBoolean(exp.getLeft(), IF22Package.Literals.AND__LEFT);
    this.checkExpectedBoolean(exp.getRight(), IF22Package.Literals.AND__RIGHT);
  }
  
  @Check
  public void checkType(final Or exp) {
    this.checkExpectedBoolean(exp.getLeft(), IF22Package.Literals.OR__LEFT);
    this.checkExpectedBoolean(exp.getRight(), IF22Package.Literals.OR__RIGHT);
  }
}
